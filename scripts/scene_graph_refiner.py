"""
Scene Graph Refiner Module
Refines medical scene graphs using knowledge base information
"""

import json
from typing import Dict, Any
from knowledge_base.retriever import KnowledgeBaseRetriever
from prompts.mccot_prompts import get_scene_graph_refinement_prompt


class SceneGraphRefiner:
    """Refines medical scene graphs using professional medical knowledge"""
    
    def __init__(self, knowledge_base_path: str, language_engine):
        """
        Initialize the scene graph refiner
        
        Args:
            knowledge_base_path: Path to processed knowledge base
            language_engine: Language model engine for refinement
        """
        self.retriever = KnowledgeBaseRetriever(knowledge_base_path)
        self.language_engine = language_engine
    
    def parse_scene_graph(self, scene_graph_text: str) -> Dict:
        """
        Parse scene graph from text to dictionary
        
        Args:
            scene_graph_text: Scene graph in text format (potentially with JSON)
            
        Returns:
            Parsed scene graph dictionary
        """
        try:
            # Try to extract JSON from the text
            start_idx = scene_graph_text.find('{')
            end_idx = scene_graph_text.rfind('}') + 1
            
            if start_idx != -1 and end_idx > start_idx:
                json_str = scene_graph_text[start_idx:end_idx]
                return json.loads(json_str)
            else:
                # If no JSON found, return empty scene graph
                return {
                    "objects": [],
                    "relationships": [],
                    "conditions": [],
                    "question_focus": []
                }
        except json.JSONDecodeError:
            print("Failed to parse scene graph JSON, returning empty scene graph")
            return {
                "objects": [],
                "relationships": [],
                "conditions": [],
                "question_focus": []
            }
    
    def refine_scene_graph(self, initial_scene_graph_text: str, verbose: bool = False) -> str:
        """
        Refine a medical scene graph using knowledge base
        
        Args:
            initial_scene_graph_text: Initial scene graph generated by MLLM
            verbose: Whether to print detailed information
            
        Returns:
            Refined scene graph text
        """
        # Parse the initial scene graph
        scene_graph_dict = self.parse_scene_graph(initial_scene_graph_text)
        
        if verbose:
            print("Parsed scene graph:", json.dumps(scene_graph_dict, indent=2))
        
        # Retrieve relevant knowledge from the knowledge base
        knowledge_dict = self.retriever.retrieve_knowledge_for_scene_graph(scene_graph_dict)
        
        if verbose:
            print(f"Retrieved knowledge for {len(knowledge_dict)} entities/relationships")
        
        # Format retrieved knowledge
        formatted_knowledge = self.retriever.format_retrieved_knowledge(knowledge_dict)
        
        if verbose:
            print("Formatted knowledge:", formatted_knowledge[:500] + "..." if len(formatted_knowledge) > 500 else formatted_knowledge)
        
        # Generate refinement prompt
        refinement_prompt = get_scene_graph_refinement_prompt(
            initial_scene_graph_text,
            formatted_knowledge
        )
        
        # Use language model to refine the scene graph
        refined_scene_graph = self.language_engine.get_response(refinement_prompt)
        
        return refined_scene_graph
    
    def validate_scene_graph(self, scene_graph_text: str) -> Dict[str, Any]:
        """
        Validate a scene graph structure
        
        Args:
            scene_graph_text: Scene graph text to validate
            
        Returns:
            Validation results dictionary
        """
        validation_results = {
            "is_valid": True,
            "errors": [],
            "warnings": []
        }
        
        # Parse scene graph
        try:
            scene_graph = self.parse_scene_graph(scene_graph_text)
        except Exception as e:
            validation_results["is_valid"] = False
            validation_results["errors"].append(f"Failed to parse scene graph: {str(e)}")
            return validation_results
        
        # Check required fields
        required_fields = ["objects", "relationships", "conditions", "question_focus"]
        for field in required_fields:
            if field not in scene_graph:
                validation_results["warnings"].append(f"Missing field: {field}")
        
        # Validate objects
        if "objects" in scene_graph:
            object_ids = set()
            for obj in scene_graph["objects"]:
                if "id" not in obj:
                    validation_results["errors"].append("Object missing 'id' field")
                    validation_results["is_valid"] = False
                else:
                    if obj["id"] in object_ids:
                        validation_results["errors"].append(f"Duplicate object ID: {obj['id']}")
                        validation_results["is_valid"] = False
                    object_ids.add(obj["id"])
                
                if "type" not in obj:
                    validation_results["warnings"].append(f"Object {obj.get('id', 'unknown')} missing 'type' field")
        
        # Validate relationships
        if "relationships" in scene_graph:
            for rel in scene_graph["relationships"]:
                if "subject" not in rel or "predicate" not in rel or "object" not in rel:
                    validation_results["errors"].append("Relationship missing required fields")
                    validation_results["is_valid"] = False
                else:
                    # Check if referenced objects exist
                    if rel["subject"] not in object_ids:
                        validation_results["warnings"].append(f"Relationship references non-existent subject: {rel['subject']}")
                    if rel["object"] not in object_ids:
                        validation_results["warnings"].append(f"Relationship references non-existent object: {rel['object']}")
        
        return validation_results
    
    def extract_key_medical_concepts(self, scene_graph_text: str) -> Dict[str, list]:
        """
        Extract key medical concepts from a scene graph
        
        Args:
            scene_graph_text: Scene graph text
            
        Returns:
            Dictionary of medical concepts by category
        """
        scene_graph = self.parse_scene_graph(scene_graph_text)
        
        concepts = {
            "anatomical_structures": [],
            "pathologies": [],
            "medical_devices": [],
            "imaging_modalities": [],
            "attributes": []
        }
        
        # Categorize objects
        for obj in scene_graph.get("objects", []):
            obj_type = obj.get("type", "").lower()
            
            # Simple categorization based on keywords
            if any(term in obj_type for term in ["organ", "lobe", "tissue", "bone", "vessel"]):
                concepts["anatomical_structures"].append(obj_type)
            elif any(term in obj_type for term in ["lesion", "nodule", "tumor", "disease", "syndrome"]):
                concepts["pathologies"].append(obj_type)
            elif any(term in obj_type for term in ["device", "catheter", "tube", "implant"]):
                concepts["medical_devices"].append(obj_type)
            elif any(term in obj_type for term in ["ct", "mri", "xray", "ultrasound"]):
                concepts["imaging_modalities"].append(obj_type)
            
            # Extract attributes
            if "attributes" in obj:
                for attr_key, attr_value in obj["attributes"].items():
                    concepts["attributes"].append(f"{attr_key}: {attr_value}")
        
        # Extract conditions
        for condition in scene_graph.get("conditions", []):
            if "type" in condition:
                concepts["pathologies"].append(condition["type"])
        
        # Remove duplicates
        for category in concepts:
            concepts[category] = list(set(concepts[category]))
        
        return concepts